<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Slide Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        .slide-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            margin: 1rem 0;
        }
        .content-widget {
            max-width: 100%;
            margin: 1rem 0;
        }
        .navigation {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        .slide-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="slideContainer" class="slide-container">
        <!-- Slides will be rendered here -->
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button id="prevBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2">
            Previous
        </button>
        <button id="nextBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
            Next
        </button>
    </div>

    <!-- Slide Indicator -->
    <div id="slideIndicator" class="slide-indicator bg-black bg-opacity-50 text-white px-3 py-1 rounded">
        <span id="currentSlide">1</span> / <span id="totalSlides">1</span>
    </div>

    <script>
        class SlideViewer {
            constructor() {
                this.slides = [];
                this.currentSlideIndex = 0;
                this.charts = new Map();
                this.init();
            }

            async init() {
                try {
                    await this.loadSlideData();
                    this.setupEventListeners();
                    this.renderCurrentSlide();
                } catch (error) {
                    console.error('Error initializing slide viewer:', error);
                    this.showError('Failed to load slide data');
                }
            }

            async loadSlideData() {
                try {
                    // Use converted_slides.json for testing
                    const response = await fetch('./converted_slides.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    this.slides = data.slide_data?.slides || [];
                    
                    if (this.slides.length === 0) {
                        throw new Error('No slides found in data');
                    }
                    
                    document.getElementById('totalSlides').textContent = this.slides.length;
                    console.log('Loaded slides:', this.slides);
                } catch (error) {
                    console.error('Error loading slide data:', error);
                    throw error;
                }
            }

            setupEventListeners() {
                document.getElementById('prevBtn').addEventListener('click', () => this.previousSlide());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextSlide());
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft') this.previousSlide();
                    if (e.key === 'ArrowRight') this.nextSlide();
                });
            }

            previousSlide() {
                if (this.currentSlideIndex > 0) {
                    this.currentSlideIndex--;
                    this.renderCurrentSlide();
                }
            }

            nextSlide() {
                if (this.currentSlideIndex < this.slides.length - 1) {
                    this.currentSlideIndex++;
                    this.renderCurrentSlide();
                }
            }

            renderCurrentSlide() {
                const slide = this.slides[this.currentSlideIndex];
                if (!slide) return;

                console.log('Rendering slide:', slide);

                // Update slide indicator
                document.getElementById('currentSlide').textContent = this.currentSlideIndex + 1;

                // Clear previous charts
                this.charts.forEach(chart => chart.dispose());
                this.charts.clear();

                // Render slide
                const container = document.getElementById('slideContainer');
                container.innerHTML = this.generateSlideHTML(slide);
                
                // Apply slide styles
                this.applySlideStyles(slide, container);

                // Render charts if present
                if (slide.widget && slide.widget.widget_type === 'chart') {
                    setTimeout(() => {
                        this.renderChart(slide.widget);
                    }, 100);
                }

                // Handle content widgets
                if (slide.widget && slide.widget.widget_type === 'content') {
                    this.renderContentWidget(slide.widget);
                }
            }

            generateSlideHTML(slide) {
                let html = '';
                
                // Title
                if (slide.title) {
                    html += `<h1 class="text-4xl font-bold mb-4 text-center">${this.escapeHtml(slide.title)}</h1>`;
                }
                
                // Subtitle
                if (slide.subtitle) {
                    html += `<h2 class="text-2xl mb-6 text-center">${this.escapeHtml(slide.subtitle)}</h2>`;
                }
                
                // Content
                if (slide.content) {
                    html += `<div class="text-lg mb-6 text-center max-w-4xl">${this.escapeHtml(slide.content)}</div>`;
                }
                
                // Widget container
                if (slide.widget) {
                    if (slide.widget.widget_type === 'chart') {
                        html += `<div id="chart-${this.currentSlideIndex}" class="chart-container"></div>`;
                    } else if (slide.widget.widget_type === 'content') {
                        html += `<div id="content-widget-${this.currentSlideIndex}" class="content-widget"></div>`;
                    }
                }
                
                return html;
            }

            applySlideStyles(slide, container) {
                if (slide.style) {
                    // Background color
                    if (slide.style.bgColor) {
                        container.style.backgroundColor = slide.style.bgColor;
                    }
                    
                    // Text color
                    if (slide.style.textColor) {
                        container.style.color = slide.style.textColor;
                    }
                    
                    // Text alignment
                    if (slide.style.align) {
                        container.style.textAlign = slide.style.align;
                    }
                }
            }

            renderChart(widget) {
                const chartContainer = document.getElementById(`chart-${this.currentSlideIndex}`);
                if (!chartContainer || !widget.widget_code) {
                    console.error('Chart container or widget_code not found');
                    return;
                }

                try {
                    console.log('Rendering chart with widget_code:', widget.widget_code);
                    
                    // Process widget_code to handle JavaScript functions
                    const chartOptions = this.processChartOptions(widget.widget_code);
                    console.log('Processed chart options:', chartOptions);
                    
                    // Create ECharts instance
                    const chart = echarts.init(chartContainer);
                    chart.setOption(chartOptions);
                    
                    // Store chart instance for cleanup
                    this.charts.set(`chart-${this.currentSlideIndex}`, chart);
                    
                    // Handle resize
                    window.addEventListener('resize', () => {
                        chart.resize();
                    });
                    
                    console.log('Chart rendered successfully');
                    
                } catch (error) {
                    console.error('Error rendering chart:', error);
                    chartContainer.innerHTML = `<div class="text-red-500 text-center p-4">Error rendering chart: ${error.message}</div>`;
                }
            }

            processChartOptions(widgetCode) {
                // Convert widget_code to proper chart options
                let options = JSON.parse(JSON.stringify(widgetCode));
                
                // Process JavaScript functions
                options = this.processJavaScriptFunctions(options);
                
                return options;
            }

            processJavaScriptFunctions(obj) {
                if (typeof obj !== 'object' || obj === null) {
                    return obj;
                }

                if (Array.isArray(obj)) {
                    return obj.map(item => this.processJavaScriptFunctions(item));
                }

                const result = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (typeof value === 'object' && value !== null && value.__js_function__ === true) {
                        // Convert JavaScript function
                        try {
                            if (value.value) {
                                // Clean up the function string
                                let funcStr = value.value;
                                
                                // Handle escaped characters
                                funcStr = funcStr.replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\'/g, "'");
                                
                                console.log('Processing JS function:', funcStr);
                                
                                // Create function
                                result[key] = new Function('return ' + funcStr)();
                            }
                        } catch (error) {
                            console.warn(`Failed to process JavaScript function for ${key}:`, error);
                            result[key] = value.value || value;
                        }
                    } else {
                        result[key] = this.processJavaScriptFunctions(value);
                    }
                }
                return result;
            }

            renderContentWidget(widget) {
                const contentContainer = document.getElementById(`content-widget-${this.currentSlideIndex}`);
                if (!contentContainer) return;

                try {
                    let content = '';
                    
                    // Handle HTML content
                    if (widget.html_content) {
                        content = widget.html_content;
                    } else if (widget.data) {
                        // Handle other data formats
                        content = `<pre class="bg-gray-200 p-4 rounded">${JSON.stringify(widget.data, null, 2)}</pre>`;
                    }
                    
                    // Handle images
                    if (widget.image_url) {
                        content += `<img src="${widget.image_url}" alt="Widget Image" class="max-w-full h-auto mx-auto">`;
                    }
                    
                    contentContainer.innerHTML = content;
                    
                } catch (error) {
                    console.error('Error rendering content widget:', error);
                    contentContainer.innerHTML = `<div class="text-red-500">Error rendering content: ${error.message}</div>`;
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showError(message) {
                const container = document.getElementById('slideContainer');
                container.innerHTML = `
                    <div class="text-center">
                        <h1 class="text-2xl font-bold text-red-600 mb-4">Error</h1>
                        <p class="text-lg">${this.escapeHtml(message)}</p>
                        <p class="text-sm text-gray-600 mt-4">Please check the console for more details.</p>
                    </div>
                `;
            }
        }

        // Initialize the slide viewer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SlideViewer();
        });
    </script>
</body>
</html>