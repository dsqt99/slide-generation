<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Financial Report - Báo Cáo Tài Chính Chuyên Nghiệp</title>
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'fade-in': 'fadeIn 0.8s ease-in-out',
                        'slide-up': 'slideUp 0.6s ease-out',
                        'scale-in': 'scaleIn 0.5s ease-out',
                        'bounce-in': 'bounceIn 0.8s ease-out',
                        'glow': 'glow 2s ease-in-out infinite alternate',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(30px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' }
                        },
                        scaleIn: {
                            '0%': { transform: 'scale(0.9)', opacity: '0' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        bounceIn: {
                            '0%': { transform: 'scale(0.3)', opacity: '0' },
                            '50%': { transform: 'scale(1.05)' },
                            '70%': { transform: 'scale(0.9)' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        glow: {
                            '0%': { boxShadow: '0 0 20px rgba(59, 130, 246, 0.5)' },
                            '100%': { boxShadow: '0 0 30px rgba(59, 130, 246, 0.8)' }
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/black.css">
    
    <!-- Modern Financial Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Custom Financial Styles -->
    <link rel="stylesheet" href="./financial-styles.css">
    
    <!-- ECharts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    
    <!-- D3.js for Graph Visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Chart Animation Manager -->
    <script src="./chart-animations.js"></script>
    
    <!-- Financial Animation Manager -->
    <script src="./financial-animations.js"></script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

</head>
<body class="financial-body">
    

    
    <!-- Financial Slide Counter -->
    <div class="financial-counter" id="financialCounter">
        <span id="currentSlide">1</span> / <span id="totalSlides">10</span>
    </div>
    
    <!-- Financial Loading Screen -->
    <div id="financialLoadingScreen" class="financial-loading">
        <div class="loading-content">
            <div class="financial-logo">
                <i class="fas fa-chart-line"></i>
            </div>
            <div class="financial-loader"></div>
            <h2 class="financial-loading-text">ĐANG TẠO BÁO CÁO TÀI CHÍNH</h2>
            <p class="financial-loading-subtext">Đang phân tích dữ liệu và tạo visualization...</p>
            <div class="financial-progress">
                <div class="financial-progress-bar"></div>
            </div>
        </div>
    </div>
    


    <!-- Navigation Buttons -->
    <div class="slide-navigation">
        <button id="prevSlideBtn" class="nav-btn nav-btn-prev" onclick="navigateSlide('prev')">
            <i class="fas fa-chevron-left"></i>
            <span>Trước</span>
        </button>
        <button id="nextSlideBtn" class="nav-btn nav-btn-next" onclick="navigateSlide('next')">
            <span>Tiếp</span>
            <i class="fas fa-chevron-right"></i>
        </button>
    </div>

    <div class="reveal financial-reveal">
        <div class="slides" id="slidesContainer">
            <!-- Slides will be dynamically generated here -->
        </div>
    </div>

    <!-- Reveal.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/highlight.js"></script>

    <script>
        // Global variables
        let slideData = [];
        let currentSlideIndex = 0;
        let totalSlides = 0;
        let financialManager = null;
        let chartInstances = new Map(); // Store chart instances for cleanup

        // Enhanced EChart JSON processing utilities
        function toEchartJson(obj) { 
            function preprocess(obj){ 
                if (obj && typeof obj === "object") { 
                    if (obj.__js_function__ && obj.value) { 
                        return `__FUNC__${obj.value}__ENDFUNC__`; 
                    } 
                    if (Array.isArray(obj)) { 
                        return obj.map(preprocess); 
                    } 
                    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, preprocess(v)])); 
                } 
                return obj; 
            } 
        
            // B1: duyệt thay thế function 
            let preprocessed = preprocess(obj); 
        
            // B2: stringify 
            let raw = JSON.stringify(preprocessed, null, 2); 
        
            // B3: thay thế chuỗi function về code JS thật 
            raw = raw.replace(/"__FUNC__/g, "").replace(/__ENDFUNC__"/g, ""); 
        
            return raw; 
        }

        // JavaScript function processing utilities
        function processJavaScriptFunction(funcStr) {
            if (typeof funcStr !== 'string') return funcStr;
            
            try {
                // Clean the function string
                let cleanFunc = funcStr.trim();
                
                // Remove 'function' keyword if present at the start
                if (cleanFunc.startsWith('function')) {
                    cleanFunc = cleanFunc.substring(8).trim();
                }
                
                // If it doesn't start with parentheses, it might be a function body only
                if (!cleanFunc.startsWith('(')) {
                    // Assume it's a function body and wrap it
                    cleanFunc = `function() { ${cleanFunc} }`;
                } else {
                    // It's a proper function definition, add 'function' keyword
                    cleanFunc = `function${cleanFunc}`;
                }
                
                // Create and return the function
                return eval(`(${cleanFunc})`);
            } catch (error) {
                console.warn('Failed to process JavaScript function:', error);
                return funcStr;
            }
        }

        function processChartOptions(options) {
            if (!options || typeof options !== 'object') return options;
            
            // Use toEchartJson for better function handling
            let processed;
            try {
                // First try to use toEchartJson if the object has __js_function__ markers
                const jsonStr = toEchartJson(options);
                processed = eval(`(${jsonStr})`);
            } catch (error) {
                console.warn('toEchartJson failed, falling back to legacy processing:', error);
                // Fallback to legacy processing
                processed = JSON.parse(JSON.stringify(options));
                
                function processObject(obj) {
                    if (!obj || typeof obj !== 'object') return obj;
                    
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            const value = obj[key];
                            
                            if (typeof value === 'object' && value !== null && value.__js_function__ && value.value) {
                                // Handle __js_function__ objects
                                obj[key] = processJavaScriptFunction(value.value);
                            } else if (typeof value === 'string' && value.includes('function')) {
                                // This might be a JavaScript function
                                obj[key] = processJavaScriptFunction(value);
                            } else if (typeof value === 'object' && value !== null) {
                                processObject(value);
                            }
                        }
                    }
                }
                
                processObject(processed);
            }
            
            return processed;
        }

        // Global cleanup function
        function cleanupAllCharts() {
            chartInstances.forEach((chart, chartId) => {
                try {
                    chart.dispose();
                    console.log('Chart disposed on cleanup:', chartId);
                } catch (error) {
                    console.warn('Error disposing chart on cleanup:', chartId, error);
                }
            });
            chartInstances.clear();
            
            // Remove all resize handlers
            document.querySelectorAll('[id^="chart-"]').forEach(element => {
                if (element._chartResizeHandler) {
                    window.removeEventListener('resize', element._chartResizeHandler);
                    delete element._chartResizeHandler;
                }
            });
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupAllCharts);

        // Initialize the financial presentation
        async function initFinancialPresentation() {
            try {
                // Initialize financial manager
                financialManager = new FinancialAnimationManager();
                
                // Load slide data
                await loadSlideData();
                
                // Generate financial slides
                generateFinancialSlides();
                
                // Initialize Reveal.js with financial settings
                initFinancialReveal();
                
                // Initialize financial charts after Reveal is ready
                Reveal.on('ready', () => {
                    initializeFinancialCharts();
                    updateNavigationButtons(); // Initialize button states
                });
                
                // Enhance keyboard navigation
                enhanceKeyboardNavigation();
                
                // Hide loading screen with financial transition
                setTimeout(() => {
                    const loadingScreen = document.getElementById('financialLoadingScreen');
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transition = 'opacity 1s ease-out';
                    
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        
                        // Initialize financial effects
                        financialManager.init();
                    }, 1000);
                }, 2000);
                
            } catch (error) {
                console.error('Error initializing financial presentation:', error);
                showFinancialErrorMessage();
            }
        }

        // Load slide data from localStorage or JSON files
        async function loadSlideData() {
            try {
                // First try to load from localStorage (from index.html)
                const storedData = localStorage.getItem('slideData');
                if (storedData) {
                    const parsedData = JSON.parse(storedData);
                    slideData = parsedData.slides || parsedData;
                    
                    totalSlides = slideData.length;
                    document.getElementById('totalSlides').textContent = totalSlides;
                    
                    // Clear stored data after loading
                    localStorage.removeItem('slideData');
                    return;
                }
                
                // Fallback to loading from JSON files
                const slideResponse = await fetch('./logs/slide.json');
                const slideJsonData = await slideResponse.json();
                // Handle both old format (direct array) and new format (with slide_data wrapper)
                slideData = slideJsonData.slide_data?.slides || slideJsonData.slides || slideJsonData;
                
                totalSlides = slideData.length;
                document.getElementById('totalSlides').textContent = totalSlides;
                
            } catch (error) {
                console.error('Error loading data:', error);
                // Fallback to demo data if files not found
                loadDemoData();
            }
        }

        // Fallback demo data
        function loadDemoData() {
            slideData = [
                {
                    id: 1,
                    title: "Welcome to AI AutoSlide",
                    subtitle: "Professional Presentation System",
                    content: "Tạo presentation chuyên nghiệp với AI và animation mượt mà",
                    style: { bgColor: "bg-gradient-to-br from-blue-600 to-purple-700", textColor: "text-white", align: "center" }
                },
                {
                    id: 2,
                    title: "Demo Chart",
                    content: "Biểu đồ tương tác với ECharts",
                    chart: true,
                    style: { bgColor: "bg-white", textColor: "text-gray-800", align: "left" }
                }
            ];
            totalSlides = slideData.length;
            document.getElementById('totalSlides').textContent = totalSlides;
        }

        // Generate financial slides dynamically with widget support
        function generateFinancialSlides() {
            const container = document.getElementById('slidesContainer');
            container.innerHTML = '';

            slideData.forEach((slide, index) => {
                const section = document.createElement('section');
                section.className = 'financial-slide';
                section.setAttribute('data-slide-index', index);
                
                // Apply custom styles if provided
                if (slide.style?.bgColor) {
                    section.classList.add(slide.style.bgColor);
                }
                if (slide.style?.textColor) {
                    section.classList.add(slide.style.textColor);
                }
                
                let slideHTML = '';
                
                // Handle new widget format
                if (slide.widget) {
                    switch (slide.widget.widget_type) {
                        case 'chart':
                            slideHTML = generateWidgetChartSlide(slide, index);
                            break;
                        case 'graph':
                            slideHTML = generateWidgetGraphSlide(slide, index);
                            break;
                        case 'table':
                            slideHTML = generateWidgetTableSlide(slide, index);
                            break;
                        case 'content':
                        default:
                            slideHTML = generateWidgetContentSlide(slide, index);
                            break;
                    }
                } else {
                    // Legacy support for old format
                    if (slide.style?.align === 'center') {
                        slideHTML = generateFinancialTitleSlide(slide, index);
                    } else if (slide.chart) {
                        slideHTML = generateFinancialChartSlide(slide, index);
                    } else if (slide.table) {
                        slideHTML = generateFinancialTableSlide(slide, index);
                    } else {
                        slideHTML = generateFinancialContentSlide(slide, index);
                    }
                }
                
                section.innerHTML = slideHTML;
                container.appendChild(section);
            });
        }

        // Generate financial title slide
        function generateFinancialTitleSlide(slide, index) {
            return `
                <div class="financial-slide-content text-center">
                    <h1 class="financial-title">${slide.title}</h1>
                    ${slide.subtitle ? `<h2 class="financial-subtitle">${slide.subtitle}</h2>` : ''}
                    <div class="financial-text-line">${slide.content}</div>
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                </div>
            `;
        }

        // Generate financial chart slide
        function generateFinancialChartSlide(slide, index) {
            return `
                <div class="financial-slide-content">
                    <div class="financial-slide-header">
                        <h2 class="financial-slide-title">${slide.title}</h2>
                    </div>
                    <div class="financial-chart">
                        <div id="chart-${index}" class="w-full h-96"></div>
                    </div>
                </div>
            `;
        }

        // Generate financial table slide
        function generateFinancialTableSlide(slide, index) {
            return `
                <div class="financial-slide-content">
                    <div class="financial-slide-header">
                        <h2 class="financial-slide-title">${slide.title}</h2>
                        ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    </div>
                    <div class="financial-table">
                        ${generateFinancialTable(slide.table)}
                    </div>
                    <div class="financial-text-line">${slide.content}</div>
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                </div>
            `;
        }

        // Generate financial content slide
        function generateFinancialContentSlide(slide, index) {
            return `
                <div class="financial-slide-content">
                    <div class="financial-slide-header">
                        <h2 class="financial-slide-title">${slide.title}</h2>
                        ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    </div>
                    <div class="financial-content-grid">
                        <div class="financial-content-block">
                            ${processFinancialContent(slide.content)}
                        </div>
                    </div>
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                </div>
            `;
        }

        // Widget slide generation functions for new format
        function generateWidgetContentSlide(slide, index) {
            const alignClass = slide.style?.align === 'center' ? 'text-center' : 
                              slide.style?.align === 'right' ? 'text-right' : 'text-left';
            
            let contentHtml = '';
            
            // Handle different content sources
            if (slide.content) {
                contentHtml = `<div class="financial-text-line">${slide.content}</div>`;
            } else if (slide.widget.html_content) {
                contentHtml = slide.widget.html_content;
            } else if (slide.widget.data && typeof slide.widget.data === 'object') {
                // Convert data object to readable content
                contentHtml = `<div class="financial-content-grid">
                    ${Object.entries(slide.widget.data).map(([key, value]) => 
                        `<div class="financial-content-block">
                            <strong class="financial-highlight">${key}:</strong> ${value}
                        </div>`
                    ).join('')}
                </div>`;
            }
            
            return `
                <div class="financial-slide-content ${alignClass}">
                    ${slide.title ? `<h2 class="financial-slide-title">${slide.title}</h2>` : ''}
                    ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                    
                    <div class="financial-content-container">
                        ${contentHtml}
                    </div>
                    
                    ${slide.button ? `<div class="financial-button-container">
                        <a href="${slide.button.url}" class="financial-nav-btn" target="_blank">
                            ${slide.button.text}
                        </a>
                    </div>` : ''}
                </div>
            `;
        }

        function generateWidgetChartSlide(slide, index) {
            const alignClass = slide.style?.align === 'center' ? 'text-center' : 
                              slide.style?.align === 'right' ? 'text-right' : 'text-left';
            
            return `
                <div class="financial-slide-content ${alignClass}">
                    ${slide.title ? `<h2 class="financial-slide-title">${slide.title}</h2>` : ''}
                    ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    
                    <div class="financial-chart">
                        <div id="chart-${slide.id}" class="w-full h-96"></div>
                    </div>
                    
                    ${slide.button ? `<div class="financial-button-container">
                        <a href="${slide.button.url}" class="financial-nav-btn" target="_blank">
                            ${slide.button.text}
                        </a>
                    </div>` : ''}
                </div>
            `;
        }

        function generateWidgetTableSlide(slide, index) {
            const alignClass = slide.style?.align === 'center' ? 'text-center' : 
                              slide.style?.align === 'right' ? 'text-right' : 'text-left';
            
            let tableHtml = '';
            
            // Helper function to format numbers and currency
            function formatCellValue(value, header) {
                if (typeof value === 'string' && value.includes('VND')) {
                    // Format Vietnamese currency
                    return value.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');
                } else if (typeof value === 'number' || (typeof value === 'string' && /^\d+\.?\d*$/.test(value))) {
                    // Format numbers with commas
                    const num = typeof value === 'number' ? value : parseFloat(value);
                    return num.toLocaleString('vi-VN');
                }
                return value;
            }
            
            // Handle different table data sources
            if (slide.widget.html_content) {
                tableHtml = slide.widget.html_content;
            } else if (slide.widget.data && slide.widget.data.columns && slide.widget.data.rows) {
                // Handle {columns: [...], rows: [...]} format from slide.json
                const columns = slide.widget.data.columns;
                const rows = slide.widget.data.rows;
                
                tableHtml = `
                    <table class="financial-table-element">
                        <thead>
                            <tr class="financial-table-row">
                                ${columns.map(column => `<th class="financial-table-header">${column}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${rows.map(row => `
                                <tr class="financial-table-row">
                                    ${row.map((cell, cellIndex) => `<td class="financial-table-cell">${formatCellValue(cell, columns[cellIndex])}</td>`).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else if (slide.widget.data && Array.isArray(slide.widget.data)) {
                // Convert array data to table
                if (slide.widget.data.length > 0) {
                    const headers = Object.keys(slide.widget.data[0]);
                    tableHtml = `
                        <table class="financial-table-element">
                            <thead>
                                <tr class="financial-table-row">
                                    ${headers.map(header => `<th class="financial-table-header">${header}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${slide.widget.data.map(row => `
                                    <tr class="financial-table-row">
                                        ${headers.map(header => `<td class="financial-table-cell">${formatCellValue(row[header] || '', header)}</td>`).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                }
            } else if (slide.widget.data && typeof slide.widget.data === 'object') {
                // Convert object data to simple table
                tableHtml = `
                    <table class="financial-table-element">
                        <tbody>
                            ${Object.entries(slide.widget.data).map(([key, value]) => `
                                <tr class="financial-table-row">
                                    <td class="financial-table-cell"><strong>${key}</strong></td>
                                    <td class="financial-table-cell">${formatCellValue(value, key)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }
            
            return `
                <div class="financial-slide-content ${alignClass}">
                    ${slide.title ? `<h2 class="financial-slide-title">${slide.title}</h2>` : ''}
                    ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                    
                    <div class="financial-table">
                        ${tableHtml}
                    </div>
                    
                    ${slide.button ? `<div class="financial-button-container">
                        <a href="${slide.button.url}" class="financial-nav-btn" target="_blank">
                            ${slide.button.text}
                        </a>
                    </div>` : ''}
                </div>
            `;
        }

        // Generate widget graph slide
        function generateWidgetGraphSlide(slide, index) {
            const alignClass = slide.style?.align === 'center' ? 'text-center' : 
                              slide.style?.align === 'right' ? 'text-right' : 'text-left';
            
            return `
                <div class="financial-slide-content ${alignClass}">
                    ${slide.title ? `<h2 class="financial-slide-title">${slide.title}</h2>` : ''}
                    ${slide.subtitle ? `<h3 class="financial-slide-subtitle">${slide.subtitle}</h3>` : ''}
                    
                    ${slide.image ? generateFinancialImageHTML(slide.image, index) : ''}
                    
                    <div class="financial-graph">
                        <div id="graph-${slide.id}" class="graph-container" style="width: 100%; height: 500px; border: 1px solid #ddd; border-radius: 8px;"></div>
                    </div>
                    
                    ${slide.button ? `<div class="financial-button-container">
                        <a href="${slide.button.url}" class="financial-nav-btn" target="_blank">
                            ${slide.button.text}
                        </a>
                    </div>` : ''}
                </div>
            `;
        }

        // Generate financial image HTML
        function generateFinancialImageHTML(imageSrc, index) {
            if (!imageSrc) return '';
            
            return `
                <div class="financial-image-container">
                    <img src="${imageSrc}" alt="Slide ${index + 1} Image" class="financial-image" 
                         loading="lazy" onload="this.style.opacity=1" style="opacity:0;transition:opacity 0.5s ease"/>
                </div>
            `;
        }

        // Process financial content
        function processFinancialContent(content) {
            if (!content) return '';
            
            // Convert HTML content and add financial classes
            let processedContent = content.replace(/<li>/g, '<li class="financial-text-line">');
            processedContent = processedContent.replace(/<p>/g, '<p class="financial-text-line">');
            processedContent = processedContent.replace(/<b>/g, '<b class="financial-highlight">');
            
            return processedContent;
        }

        // Generate financial table
        function generateFinancialTable(tableData) {
            if (!tableData || !tableData.headers || !tableData.rows) return '';
            
            let tableHTML = '<table class="financial-table-element"><thead><tr>';
            
            tableData.headers.forEach(header => {
                tableHTML += `<th class="financial-table-header">${header}</th>`;
            });
            
            tableHTML += '</tr></thead><tbody>';
            
            tableData.rows.forEach(row => {
                tableHTML += '<tr class="financial-table-row">';
                row.forEach(cell => {
                    tableHTML += `<td class="financial-table-cell">${cell}</td>`;
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            return tableHTML;
        }

        // Navigation debouncing
        let navigationCooldown = false;
        const NAVIGATION_DELAY = 300; // ms



        // Generate table HTML
        function generateTable(tableData) {
            let tableHTML = '<table class="data-table">';
            
            // Headers
            tableHTML += '<thead><tr>';
            tableData.headers.forEach(header => {
                tableHTML += `<th>${header}</th>`;
            });
            tableHTML += '</tr></thead>';
            
            // Rows
            tableHTML += '<tbody>';
            tableData.rows.forEach(row => {
                tableHTML += '<tr>';
                row.forEach(cell => {
                    tableHTML += `<td>${cell}</td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';
            
            return tableHTML;
        }

        // Initialize Financial Reveal.js
        function initFinancialReveal() {
            Reveal.initialize({
                hash: true,
                controls: false,
                progress: false,
                center: false, // Disable centering to use full screen
                transition: 'slide', // Clean slide transition without blur
                transitionSpeed: 'default', // Balanced speed for smooth feel
                backgroundTransition: 'slide',
                parallaxBackgroundImage: '',
                parallaxBackgroundSize: '',
                parallaxBackgroundHorizontal: null,
                parallaxBackgroundVertical: null,
                
                // Full Screen Configuration
                width: '100%',
                height: '100%',
                margin: 0,
                minScale: 1,
                maxScale: 1,
                
                // Performance optimizations
                embedded: false,
                touch: false,
                loop: false,
                rtl: false,
                navigationMode: 'default',
                shuffle: false,
                fragments: true,
                fragmentInURL: false,
                hashOneBasedIndex: false,
                respondToHashChanges: true,
                jumpToSlide: true,
                
                // Plugins
                plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
                
                // Keyboard shortcuts - hoạt động với Reveal mặc định
                keyboard: true
            });

            // Update slide counter on slide change
            Reveal.on('slidechanged', event => {
                currentSlideIndex = event.indexh;
                updateFinancialCounter();
                updateNavigationButtons(); // Update navigation button states
                
                console.log('Slide changed from', event.previousSlide?.id || 'none', 'to', event.currentSlide?.id || 'none');
                
                // Cleanup charts from previous slide if exists
                // Only cleanup if we're actually moving to a different slide
                if (event.previousSlide && event.previousSlide !== event.currentSlide) {
                    // Use setTimeout to avoid conflicts with initialization
                    setTimeout(() => {
                        cleanupChartsOnSlide(event.previousSlide);
                    }, 50);
                }
                
                // Optimized slide animations with debouncing
                if (financialManager) {
                    financialManager.playTransitionSound();
                    
                    // Use requestAnimationFrame for smooth animations
                    requestAnimationFrame(() => {
                        animateSlideElements(event.currentSlide);
                    });
                }
                
                // Initialize charts for newly visible slide with delay
                // This ensures DOM is fully ready and cleanup is complete
                setTimeout(() => {
                    initializeChartsOnSlide(event.currentSlide);
                }, 150);
            });

            // Initialize slide counter
            updateFinancialCounter();
        }

        // Initialize financial charts
        function initializeFinancialCharts() {
            console.log('initializeFinancialCharts: Starting chart initialization');
            
            // Initialize charts for current slide only
            // Other slides will be initialized when navigated to
            const currentSlide = Reveal.getCurrentSlide();
            if (currentSlide) {
                console.log('Initializing charts for current slide:', currentSlide.id || 'unnamed');
                initializeChartsOnSlide(currentSlide);
            } else {
                console.warn('No current slide found for chart initialization');
            }
        }

        // Update financial counter
        function updateFinancialCounter() {
            document.getElementById('currentSlide').textContent = currentSlideIndex + 1;
        }

        // Animate slide elements with optimized performance
        function animateSlideElements(slide) {
            const elements = slide.querySelectorAll('.financial-title, .financial-subtitle, .financial-text-line, .financial-chart, .financial-table');
            
            // Batch DOM operations for better performance
            elements.forEach((element, index) => {
                element.style.cssText = `
                    opacity: 0;
                    transform: translateY(30px) translateZ(0);
                    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                `;
            });
            
            // Use requestAnimationFrame for smooth animations
            elements.forEach((element, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        element.style.cssText = `
                            opacity: 1;
                            transform: translateY(0) translateZ(0);
                            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        `;
                    });
                }, index * 100); // Reduced delay for faster animations
            });
        }

        // Show financial error message
        function showFinancialErrorMessage() {
            document.getElementById('financialLoadingScreen').innerHTML = `
                <div class="loading-content">
                    <div class="financial-logo">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <h2 class="financial-loading-text">LỖI HỆ THỐNG</h2>
                    <p class="financial-loading-subtext">Không thể khởi tạo báo cáo tài chính...</p>
                    <button onclick="location.reload()" class="financial-nav-btn">
                        THỬ LẠI
                    </button>
                </div>
            `;
        }

        // Create financial chart
        function createFinancialChart(elementId, data, slideIndex) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Dispose existing chart if exists
            if (chartInstances.has(elementId)) {
                const existingChart = chartInstances.get(elementId);
                try {
                    existingChart.dispose();
                } catch (error) {
                    console.warn('Error disposing existing chart:', elementId, error);
                }
            }
            
            const chart = echarts.init(element);
            
            // Log original data for debugging
            console.log('Original chart data for', elementId, ':', data);
            
            // Process chart options with toEchartJson
            const processedData = processChartOptions(data);
            console.log('Processed chart data for', elementId, ':', processedData);
            
            const option = {
                backgroundColor: 'white',
                textStyle: {
                    fontFamily: 'Inter, sans-serif',
                    color: '#1e3a8a'
                },
                ...processedData
            };
            
            chart.setOption(option);
            
            // Store chart instance for cleanup
            chartInstances.set(elementId, chart);
            
            // Create resize handler
            const resizeHandler = () => {
                if (chart && !chart.isDisposed()) {
                    chart.resize();
                }
            };
            
            // Store resize handler for cleanup
            element._chartResizeHandler = resizeHandler;
            window.addEventListener('resize', resizeHandler);
            
            console.log('Financial chart created:', elementId);
        }

        // Create financial demo chart
        function createFinancialDemoChart(elementId, slideIndex) {
            const demoData = {
                title: {
                    text: 'DOANH THU VÀ LỢI NHUẬN',
                    textStyle: {
                        color: '#1e3a8a',
                        fontFamily: 'Inter, sans-serif',
                        fontSize: 18,
                        fontWeight: 'bold'
                    }
                },
                grid: {
                    borderColor: '#e2e8f0',
                    borderWidth: 1
                },
                xAxis: {
                    type: 'category',
                    data: ['2020', '2021', '2022', '2023', '2024'],
                    axisLine: {
                        lineStyle: { color: '#64748b' }
                    },
                    axisLabel: {
                        color: '#64748b',
                        fontFamily: 'Inter, sans-serif'
                    }
                },
                yAxis: {
                    type: 'value',
                    axisLine: {
                        lineStyle: { color: '#64748b' }
                    },
                    axisLabel: {
                        color: '#64748b',
                        fontFamily: 'Inter, sans-serif'
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(100, 116, 139, 0.1)'
                        }
                    }
                },
                series: [{
                    name: 'Doanh thu',
                    type: 'bar',
                    data: [29830, 35657, 44009, 52617, 62848],
                    itemStyle: {
                        color: {
                            type: 'linear',
                            x: 0, y: 0, x2: 0, y2: 1,
                            colorStops: [
                                { offset: 0, color: '#1e3a8a' },
                                { offset: 1, color: '#3b82f6' }
                            ]
                        }
                    }
                }, {
                    name: 'Lợi nhuận',
                    type: 'line',
                    data: [4423, 5349, 6491, 7788, 9427],
                    smooth: true,
                    itemStyle: {
                        color: '#f59e0b'
                    },
                    lineStyle: {
                        width: 3,
                        color: '#f59e0b'
                    },
                    areaStyle: {
                        color: {
                            type: 'linear',
                            x: 0, y: 0, x2: 0, y2: 1,
                            colorStops: [
                                { offset: 0, color: 'rgba(245, 158, 11, 0.3)' },
                                { offset: 1, color: 'rgba(245, 158, 11, 0.05)' }
                            ]
                        }
                    }
                }]
            };
            
            createFinancialChart(elementId, demoData, slideIndex);
        }

        // Cleanup chart instances for a specific slide
        function cleanupChartsOnSlide(slide) {
            if (!slide) {
                console.warn('cleanupChartsOnSlide: No slide provided');
                return;
            }
            
            const chartElements = slide.querySelectorAll('[id^="chart-"]');
            console.log('cleanupChartsOnSlide: Found', chartElements.length, 'chart elements to cleanup');
            
            chartElements.forEach((element) => {
                const chartId = element.id;
                
                // Only dispose if chart instance exists and is not already disposed
                if (chartInstances.has(chartId)) {
                    const chartInstance = chartInstances.get(chartId);
                    try {
                        if (chartInstance && !chartInstance.isDisposed()) {
                            chartInstance.dispose();
                            console.log('Chart disposed:', chartId);
                        } else {
                            console.log('Chart already disposed or invalid:', chartId);
                        }
                    } catch (error) {
                        console.warn('Error disposing chart:', chartId, error);
                    }
                    chartInstances.delete(chartId);
                }
                
                // Remove resize event listeners
                if (element._chartResizeHandler) {
                    window.removeEventListener('resize', element._chartResizeHandler);
                    delete element._chartResizeHandler;
                    console.log('Removed resize handler for:', chartId);
                }
            });
        }

        // Initialize charts on current slide
        function initializeChartsOnSlide(slide) {
            if (!slide) {
                console.warn('initializeChartsOnSlide: No slide provided');
                return;
            }
            
            const chartElements = slide.querySelectorAll('[id^="chart-"]');
            const graphElements = slide.querySelectorAll('[id^="graph-"]');
            console.log('initializeChartsOnSlide: Found', chartElements.length, 'chart elements and', graphElements.length, 'graph elements');
            
            chartElements.forEach((element, index) => {
                const chartId = element.id;
                
                // Check if chart already exists and is not disposed
                if (chartInstances.has(chartId)) {
                    const existingChart = chartInstances.get(chartId);
                    if (existingChart && !existingChart.isDisposed()) {
                        console.log('Chart already exists and is active:', chartId);
                        // Resize existing chart to ensure proper display
                        try {
                            existingChart.resize();
                            return; // Skip re-creation
                        } catch (error) {
                            console.warn('Error resizing existing chart:', chartId, error);
                            // Continue to re-create chart
                        }
                    }
                }
                
                // Clean up any existing chart instance for this element
                if (chartInstances.has(chartId)) {
                    const chartInstance = chartInstances.get(chartId);
                    try {
                        chartInstance.dispose();
                        console.log('Disposed existing chart:', chartId);
                    } catch (error) {
                        console.warn('Error disposing existing chart:', chartId, error);
                    }
                    chartInstances.delete(chartId);
                }
                
                // Remove any existing resize handlers
                if (element._chartResizeHandler) {
                    window.removeEventListener('resize', element._chartResizeHandler);
                    delete element._chartResizeHandler;
                }
                
                const slideIndex = parseInt(chartId.split('-')[1]);
                
                // Find slide info by ID or by array index
                let slideInfo = slideData.find(slide => slide.id === slideIndex);
                if (!slideInfo) {
                    // Fallback to array index (0-based)
                    slideInfo = slideData[slideIndex - 1] || slideData[slideIndex];
                }
                
                console.log('Processing chart:', chartId, 'slideIndex:', slideIndex, 'slideInfo found:', !!slideInfo);
                
                // Add a small delay to ensure DOM is ready
                setTimeout(() => {
                    // Check for new widget format first
                    if (slideInfo?.widget?.widget_type === 'chart') {
                        // Check if widget_code has actual chart configuration
                        let chartConfig;
                        if (slideInfo.widget.widget_code && 
                            typeof slideInfo.widget.widget_code === 'object' && 
                            Object.keys(slideInfo.widget.widget_code).length > 0 &&
                            (slideInfo.widget.widget_code.series || slideInfo.widget.widget_code.xAxis || slideInfo.widget.widget_code.yAxis)) {
                            // Use widget_code (ECharts format)
                            chartConfig = slideInfo.widget.widget_code;
                            console.log('Using widget_code for chart:', chartId);
                        } else if (slideInfo.widget.data && 
                                   typeof slideInfo.widget.data === 'object' && 
                                   Object.keys(slideInfo.widget.data).length > 0) {
                            // Use data (Chart.js format)
                            chartConfig = slideInfo.widget.data;
                            console.log('Using widget data for chart:', chartId);
                        } else {
                            console.warn('No valid chart data found for:', chartId);
                            return;
                        }
                        
                        createWidgetChart(chartId, chartConfig, slideIndex);
                    }
                    // Fallback to old format
                    else if (slideInfo?.chart) {
                        createDemoChart(chartId, slideIndex);
                    }
                    // Fallback to demo chart if no data found
                    else {
                        console.log('No chart data found, creating demo chart for:', chartId);
                        createFinancialDemoChart(chartId, slideIndex);
                    }
                }, 100); // Small delay to ensure DOM is ready
            });
            
            // Process graph elements
            graphElements.forEach((element, index) => {
                const graphId = element.id;
                const slideIndex = parseInt(graphId.split('-')[1]);
                
                // Find slide info by ID or by array index
                let slideInfo = slideData.find(slide => slide.id === slideIndex);
                if (!slideInfo) {
                    slideInfo = slideData[slideIndex - 1] || slideData[slideIndex];
                }
                
                console.log('Processing graph:', graphId, 'slideIndex:', slideIndex, 'slideInfo found:', !!slideInfo);
                
                // Add a small delay to ensure DOM is ready
                setTimeout(() => {
                    if (slideInfo?.widget?.widget_type === 'graph') {
                        createWidgetGraph(graphId, slideInfo.widget.data, slideIndex);
                    }
                }, 100);
            });
        }

        // Create widget graph using D3.js
        function createWidgetGraph(elementId, graphData, slideIndex) {
            console.log('Creating graph for:', elementId, 'with data:', graphData);
            console.log('D3 available:', typeof d3 !== 'undefined');
            console.log('Graph data nodes:', graphData?.nodes?.length);
            console.log('Graph data links:', graphData?.links?.length);
            
            const container = document.getElementById(elementId);
            if (!container) {
                console.error('Graph container not found:', elementId);
                return;
            }
            
            // Clear any existing content
            d3.select(`#${elementId}`).selectAll("*").remove();
            
            const nodes = graphData.nodes || [];
            const links = graphData.links || [];
            
            if (nodes.length === 0) {
                console.warn('No nodes data found for graph:', elementId);
                return;
            }
            
            // Set up dimensions
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 500;
            
            // Create SVG
            const svg = d3.select(`#${elementId}`)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2));
            
            // Create links
            const link = svg.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2);
            
            // Create nodes
            const node = svg.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', 20)
                .attr('fill', d => d.label.includes('Nam') ? '#3b82f6' : '#ec4899')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels
            const label = svg.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.label)
                .attr('font-size', '12px')
                .attr('font-family', 'Arial, sans-serif')
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em');
            
            // Add tooltips
            node.append('title')
                .text(d => d.label);
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth || 800;
                const newHeight = container.clientHeight || 500;
                svg.attr('width', newWidth).attr('height', newHeight);
                simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
                simulation.alpha(0.3).restart();
            });
        }

        // Create demo chart for demonstration
        function createDemoChart(elementId, slideIndex) {
            const demoData = {
                title: {
                    text: 'DOANH THU VÀ LỢI NHUẬN',
                    textStyle: {
                        color: '#1e3a8a',
                        fontFamily: 'Inter, sans-serif',
                        fontSize: 18,
                        fontWeight: 'bold'
                    }
                },
                grid: {
                    borderColor: '#e2e8f0',
                    borderWidth: 1
                },
                xAxis: {
                    type: 'category',
                    data: ['2020', '2021', '2022', '2023', '2024'],
                    axisLine: {
                        lineStyle: { color: '#64748b' }
                    },
                    axisLabel: {
                        color: '#64748b',
                        fontFamily: 'Inter, sans-serif'
                    }
                },
                yAxis: {
                    type: 'value',
                    axisLine: {
                        lineStyle: { color: '#64748b' }
                    },
                    axisLabel: {
                        color: '#64748b',
                        fontFamily: 'Inter, sans-serif'
                    },
                    splitLine: {
                        lineStyle: {
                            color: 'rgba(100, 116, 139, 0.1)'
                        }
                    }
                },
                series: [{
                    name: 'Doanh thu',
                    type: 'bar',
                    data: [29830, 35657, 44009, 52617, 62848],
                    itemStyle: {
                        color: {
                            type: 'linear',
                            x: 0, y: 0, x2: 0, y2: 1,
                            colorStops: [
                                { offset: 0, color: '#3b82f6' },
                                { offset: 1, color: '#1d4ed8' }
                            ]
                        }
                    }
                }, {
                    name: 'Lợi nhuận',
                    type: 'line',
                    data: [4423, 5349, 6491, 7788, 9427],
                    smooth: true,
                    itemStyle: {
                        color: '#10b981'
                    },
                    lineStyle: {
                        width: 3
                    }
                }]
            };
            
            createFinancialChart(elementId, demoData, slideIndex);
        }

        // Convert Chart.js format to ECharts format
        function convertChartJsToECharts(chartJsData) {
            if (!chartJsData || !chartJsData.labels || !chartJsData.datasets) {
                console.warn('Invalid Chart.js data format');
                return null;
            }
            
            const { labels, datasets } = chartJsData;
            const firstDataset = datasets[0] || {};
            
            // Determine chart type based on dataset
            let chartType = 'bar'; // default
            if (firstDataset.type) {
                chartType = firstDataset.type;
            }
            
            const option = {
                backgroundColor: 'transparent',
                title: {
                    text: firstDataset.label || 'Chart',
                    textStyle: {
                        color: '#1e3a8a',
                        fontFamily: 'Inter, sans-serif',
                        fontSize: 18,
                        fontWeight: 'bold'
                    }
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '3%',
                    containLabel: true,
                    borderColor: '#e2e8f0',
                    borderWidth: 1
                },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: '#e2e8f0',
                    textStyle: {
                        color: '#374151',
                        fontFamily: 'Inter, sans-serif'
                    }
                },
                legend: {
                    data: datasets.map(d => d.label || 'Data'),
                    textStyle: {
                        color: '#64748b',
                        fontFamily: 'Inter, sans-serif'
                    }
                }
            };
            
            if (chartType === 'pie') {
                // For pie charts, convert data format
                const pieData = labels.map((label, index) => ({
                    name: label,
                    value: firstDataset.data[index] || 0
                }));
                
                option.series = [{
                    name: firstDataset.label || 'Data',
                    type: 'pie',
                    radius: '50%',
                    data: pieData,
                    emphasis: {
                        itemStyle: {
                            shadowBlur: 10,
                            shadowOffsetX: 0,
                            shadowColor: 'rgba(0, 0, 0, 0.5)'
                        }
                    }
                }];
            } else {
                // For bar/line charts
                option.xAxis = {
                    type: 'category',
                    data: labels,
                    axisLine: { lineStyle: { color: '#64748b' } },
                    axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' }
                };
                option.yAxis = {
                    type: 'value',
                    axisLine: { lineStyle: { color: '#64748b' } },
                    axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' },
                    splitLine: { lineStyle: { color: '#e2e8f0' } }
                };
                
                option.series = datasets.map((dataset, index) => {
                    const series = {
                        name: dataset.label || `Series ${index + 1}`,
                        type: chartType === 'line' ? 'line' : 'bar',
                        data: dataset.data || []
                    };
                    
                    if (chartType === 'line') {
                        series.smooth = true;
                        series.lineStyle = { width: 3 };
                        series.itemStyle = { color: dataset.backgroundColor || '#10b981' };
                    } else {
                        series.itemStyle = {
                            color: dataset.backgroundColor || new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                { offset: 0, color: '#3b82f6' },
                                { offset: 1, color: '#1d4ed8' }
                            ])
                        };
                    }
                    
                    return series;
                });
            }
            
            return option;
        }

        // Create widget chart for new format
        function createWidgetChart(elementId, chartConfig, slideIndex) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.error('Chart element not found:', elementId);
                return;
            }
            
            try {
                // Dispose existing chart if exists
                if (chartInstances.has(elementId)) {
                    const existingChart = chartInstances.get(elementId);
                    try {
                        existingChart.dispose();
                        console.log('Existing chart disposed:', elementId);
                    } catch (error) {
                        console.warn('Error disposing existing chart:', elementId, error);
                    }
                }
                
                const chart = echarts.init(element);
                let option;
                
                // Check if chartConfig is a complete ECharts configuration (widget_code format)
                if (chartConfig && typeof chartConfig === 'object' && 
                    (chartConfig.series || chartConfig.xAxis || chartConfig.yAxis || chartConfig.title)) {
                    
                    console.log('Using widget_code format for chart:', elementId);
                    
                    // Process the chart configuration to handle JavaScript functions
                    option = processChartOptions(chartConfig);
                    
                } else if (chartConfig && chartConfig.labels && chartConfig.datasets) {
                    // Chart.js format - convert to ECharts
                    console.log('Converting Chart.js format to ECharts for chart:', elementId);
                    
                    option = convertChartJsToECharts(chartConfig);
                    if (!option) {
                        throw new Error('Failed to convert Chart.js data to ECharts format');
                    }
                    
                } else {
                    // Fallback to old data format
                    console.log('Using legacy data format for chart:', elementId);
                    
                    const chartData = chartConfig;
                    
                    // Default chart configuration for legacy format
                    option = {
                        backgroundColor: 'transparent',
                        title: {
                            text: chartData?.title || 'Chart',
                            textStyle: {
                                color: '#1e3a8a',
                                fontFamily: 'Inter, sans-serif',
                                fontSize: 18,
                                fontWeight: 'bold'
                            }
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            containLabel: true,
                            borderColor: '#e2e8f0',
                            borderWidth: 1
                        },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: '#e2e8f0',
                            textStyle: {
                                color: '#374151',
                                fontFamily: 'Inter, sans-serif'
                            }
                        },
                        legend: {
                            data: chartData?.series?.map(s => s.name) || [],
                            textStyle: {
                                color: '#64748b',
                                fontFamily: 'Inter, sans-serif'
                            }
                        }
                    };
                    
                    // Handle different chart types for legacy format
                    if (chartData?.type === 'bar' || !chartData?.type) {
                        option.xAxis = {
                            type: 'category',
                            data: chartData?.categories || ['Category 1', 'Category 2', 'Category 3'],
                            axisLine: { lineStyle: { color: '#64748b' } },
                            axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' }
                        };
                        option.yAxis = {
                            type: 'value',
                            axisLine: { lineStyle: { color: '#64748b' } },
                            axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' },
                            splitLine: { lineStyle: { color: '#e2e8f0' } }
                        };
                        option.series = chartData?.series || [{
                            name: 'Data',
                            type: 'bar',
                            data: [120, 200, 150],
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#3b82f6' },
                                    { offset: 1, color: '#1d4ed8' }
                                ])
                            }
                        }];
                    } else if (chartData?.type === 'line') {
                        option.xAxis = {
                            type: 'category',
                            data: chartData?.categories || ['Jan', 'Feb', 'Mar', 'Apr', 'May'],
                            axisLine: { lineStyle: { color: '#64748b' } },
                            axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' }
                        };
                        option.yAxis = {
                            type: 'value',
                            axisLine: { lineStyle: { color: '#64748b' } },
                            axisLabel: { color: '#64748b', fontFamily: 'Inter, sans-serif' },
                            splitLine: { lineStyle: { color: '#e2e8f0' } }
                        };
                        option.series = chartData?.series || [{
                            name: 'Data',
                            type: 'line',
                            data: [120, 200, 150, 80, 70],
                            smooth: true,
                            itemStyle: { color: '#10b981' },
                            lineStyle: { width: 3 }
                        }];
                    } else if (chartData?.type === 'pie') {
                        option.series = [{
                            name: 'Data',
                            type: 'pie',
                            radius: '50%',
                            data: chartData?.series?.[0]?.data || [
                                { value: 1048, name: 'Category A' },
                                { value: 735, name: 'Category B' },
                                { value: 580, name: 'Category C' }
                            ],
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowOffsetX: 0,
                                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                                }
                            }
                        }];
                    }
                }
                
                // Set the chart option
                chart.setOption(option);
                
                // Store chart instance for cleanup
                chartInstances.set(elementId, chart);
                
                // Handle resize
                const resizeHandler = () => {
                    if (chart && !chart.isDisposed()) {
                        chart.resize();
                    }
                };
                window.addEventListener('resize', resizeHandler);
                
                // Store resize handler for cleanup
                element._chartResizeHandler = resizeHandler;
                
                console.log('Chart created successfully:', elementId);
                
            } catch (error) {
                console.error('Error creating chart:', elementId, error);
                
                // Show error message in the chart container
                element.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; font-family: Inter, sans-serif;">
                        <div style="text-align: center;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <div>Lỗi tải biểu đồ</div>
                            <div style="font-size: 0.875rem; color: #6b7280; margin-top: 0.5rem;">
                                ${error.message}
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // Show error message
        function showErrorMessage() {
            document.getElementById('loadingScreen').innerHTML = `
                <div class="text-center text-white">
                    <i class="fas fa-exclamation-triangle text-6xl mb-4 text-yellow-400"></i>
                    <h2 class="text-2xl font-bold mb-2">Lỗi tải dữ liệu</h2>
                    <p class="text-blue-200 mb-4">Không thể tải dữ liệu slide. Sử dụng dữ liệu demo.</p>
                    <button onclick="location.reload()" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-semibold hover:bg-gray-100 transition-colors">
                        Thử lại
                    </button>
                </div>
            `;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            switch(event.key) {
                case 'f':
                case 'F':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        Reveal.toggleFullscreen();
                    }
                    break;
                case 'o':
                case 'O':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        Reveal.toggleOverview();
                    }
                    break;
            }
        });

        // Particle System
        function initParticleSystem() {
            const container = document.getElementById('particlesContainer');
            const particleCount = 50;
            
            for (let i = 0; i < particleCount; i++) {
                createParticle(container);
            }
        }

        function createParticle(container) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Random position and animation delay
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (15 + Math.random() * 10) + 's';
            
            container.appendChild(particle);
            
            // Remove and recreate particle when animation ends
            particle.addEventListener('animationend', () => {
                container.removeChild(particle);
                createParticle(container);
            });
        }

        function startParticleAnimation() {
            const particles = document.querySelectorAll('.particle');
            particles.forEach((particle, index) => {
                setTimeout(() => {
                    particle.style.animationPlayState = 'running';
                }, index * 100);
            });
        }

        // Parallax Effects
        function initParallaxEffects() {
            document.addEventListener('mousemove', handleParallax);
        }

        function handleParallax(e) {
            const parallaxElements = document.querySelectorAll('.parallax-element');
            const mouseX = e.clientX / window.innerWidth;
            const mouseY = e.clientY / window.innerHeight;
            
            parallaxElements.forEach(element => {
                const speed = element.dataset.speed || 0.5;
                const x = (mouseX - 0.5) * speed * 50;
                const y = (mouseY - 0.5) * speed * 50;
                
                element.style.transform = `translate3d(${x}px, ${y}px, 0) rotateX(${y * 0.1}deg) rotateY(${x * 0.1}deg)`;
            });
        }

        // Enhanced slide transitions
        function enhanceSlideTransitions() {
            const slides = document.querySelectorAll('.slide-content');
            
            slides.forEach((slide, index) => {
                slide.addEventListener('mouseenter', () => {
                    slide.style.transform = 'translateY(-8px) scale(1.02)';
                    
                    // Add ripple effect
                    createRippleEffect(slide, event);
                });
                
                slide.addEventListener('mouseleave', () => {
                    slide.style.transform = 'translateY(0) scale(1)';
                });
            });
        }

        // Create ripple effect
        function createRippleEffect(element, event) {
            const ripple = document.createElement('div');
            const rect = element.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            ripple.style.cssText = `
                position: absolute;
                border-radius: 50%;
                background: rgba(59, 130, 246, 0.3);
                transform: scale(0);
                animation: ripple 0.6s linear;
                left: ${x - 10}px;
                top: ${y - 10}px;
                width: 20px;
                height: 20px;
                pointer-events: none;
                z-index: 1000;
            `;
            
            element.style.position = 'relative';
            element.appendChild(ripple);
            
            setTimeout(() => {
                if (element.contains(ripple)) {
                    element.removeChild(ripple);
                }
            }, 600);
        }

        // Sound effects (optional)
        function playSlideSound() {
            // Create audio context for subtle sound effects
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                try {
                    const audioContext = new (AudioContext || webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    // Silently fail if audio context is not available
                }
            }
        }

        // Trigger slide-specific animations
        function triggerSlideAnimations(slide) {
            const animationType = slide.getAttribute('data-transition');
            const elements = slide.querySelectorAll('.interactive-element');
            
            // Reset and trigger animations
            elements.forEach((element, index) => {
                element.style.animation = 'none';
                element.offsetHeight; // Trigger reflow
                
                setTimeout(() => {
                    element.style.animation = '';
                    element.classList.add('animate-fade-in');
                }, index * 100);
            });
            
            // Special effects for different slide types
            const chartElements = slide.querySelectorAll('[id^="chart-"]');
            if (chartElements.length > 0) {
                chartElements.forEach(chartEl => {
                    chartEl.style.transform = 'scale(0.8)';
                    chartEl.style.opacity = '0';
                    
                    setTimeout(() => {
                        chartEl.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        chartEl.style.transform = 'scale(1)';
                        chartEl.style.opacity = '1';
                    }, 300);
                });
            }
            
            // Image animations
            const images = slide.querySelectorAll('.image-container img');
            images.forEach((img, index) => {
                img.style.transform = 'scale(1.2)';
                img.style.opacity = '0';
                
                setTimeout(() => {
                    img.style.transition = 'all 0.6s ease-out';
                    img.style.transform = 'scale(1)';
                    img.style.opacity = '1';
                }, 500 + index * 200);
            });
        }





        // Navigation function for slide buttons
        function navigateSlide(direction) {
            if (!Reveal) return;
            
            const prevBtn = document.getElementById('prevSlideBtn');
            const nextBtn = document.getElementById('nextSlideBtn');
            
            // Add pulse animation
            const activeBtn = direction === 'prev' ? prevBtn : nextBtn;
            if (activeBtn) {
                activeBtn.classList.add('pulse');
                setTimeout(() => activeBtn.classList.remove('pulse'), 600);
            }
            
            // Navigate using Reveal.js
            if (direction === 'prev') {
                Reveal.prev();
            } else if (direction === 'next') {
                Reveal.next();
            }
            
            // Update button states after navigation
            setTimeout(updateNavigationButtons, 100);
        }

        // Update navigation button states
        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevSlideBtn');
            const nextBtn = document.getElementById('nextSlideBtn');
            
            if (!prevBtn || !nextBtn || !Reveal) return;
            
            // Get current slide indices
            const indices = Reveal.getIndices();
            const isFirstSlide = indices.h === 0 && indices.v === 0;
            const isLastSlide = Reveal.isLastSlide();
            
            // Update button states
            prevBtn.disabled = isFirstSlide;
            nextBtn.disabled = isLastSlide;
            
            // Update button text for better UX
            if (isFirstSlide) {
                prevBtn.style.opacity = '0.5';
            } else {
                prevBtn.style.opacity = '1';
            }
            
            if (isLastSlide) {
                nextBtn.style.opacity = '0.5';
            } else {
                nextBtn.style.opacity = '1';
            }
        }

        // Keyboard navigation enhancement
        function enhanceKeyboardNavigation() {
            document.addEventListener('keydown', (event) => {
                // Prevent default if we're handling the key
                if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                    event.preventDefault();
                    
                    if (event.key === 'ArrowLeft') {
                        navigateSlide('prev');
                    } else if (event.key === 'ArrowRight') {
                        navigateSlide('next');
                    }
                }
            });
        }

        // Initialize financial presentation when page loads
        document.addEventListener('DOMContentLoaded', initFinancialPresentation);
    </script>
</body>
</html>